{"version":3,"sources":["ng://@opten/ng-jwt/lib/is-token-expired.ts","ng://@opten/ng-jwt/lib/token.config.ts","ng://@opten/ng-jwt/lib/token.service.ts","ng://@opten/ng-jwt/lib/token.interceptor.ts","ng://@opten/ng-jwt/lib/jwt.module.ts"],"names":["isTokenExpired","token","offsetSeconds","date","getTokenExpirationDate","expiration","Date","setUTCSeconds","valueOf","JWT_CONFIG","InjectionToken","TokenService","config","http","this","prototype","request","_this","post","tokenEndpoint","headers","Skip-Token","pipe","map","access_token","setToken","get","getToken","mergeMap","grant_type","refresh_token","observableOf","Injectable","Inject","args","HttpClient","JwtInterceptor","_config","tokenService","_isRefreshingToken","_tokenSubject","BehaviorSubject","intercept","next","skipIssuingToken","has","delete","handle","clone","_addToken","finalize","filter","take","switchMap","_isWhitelistedHost","url","whitelistedDomains","set","headerName","authScheme","whitelist","host","_getHost","o","toLowerCase","indexOf","href","window","URL","match","JwtModule","parentModule","Error","forRoot","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","useValue","NgModule","decorators","type","Optional","SkipSelf"],"mappings":"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","sourcesContent":["import { JwtTokenResponse } from './jwt-token-response';\r\n\r\nfunction getTokenExpirationDate(token: JwtTokenResponse): Date {\r\n\tif (!token || token == null || !token.expiration) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst date: Date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n\tdate.setUTCSeconds(token.expiration);\r\n\r\n\treturn date;\r\n}\r\n\r\nexport function isTokenExpired(\r\n\ttoken: JwtTokenResponse,\r\n\toffsetSeconds?: number\r\n): boolean {\r\n\toffsetSeconds = offsetSeconds || 0;\r\n\r\n\tconst date: Date = getTokenExpirationDate(token);\r\n\r\n\tif (!date || date == null) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { JwtTokenResponse } from './jwt-token-response';\r\n\r\nexport type JwtConfig = {\r\n\ttokenEndpoint: string;\r\n\theaderName: string;\r\n\tauthScheme: string;\r\n\twhitelistedDomains: Array<string>;\r\n\tsetToken: (token: JwtTokenResponse) => void;\r\n\tgetToken: () => Observable<JwtTokenResponse>;\r\n};\r\n\r\nexport const JWT_CONFIG = new InjectionToken<JwtConfig>('jwt-config');\r\n","import { Injectable, Inject } from '@angular/core';\r\n\r\nimport { HttpClient } from '@angular/common/http';\r\n\r\nimport { Observable, of as observableOf } from 'rxjs';\r\nimport { mergeMap, map } from 'rxjs/operators';\r\n\r\nimport { isTokenExpired } from './is-token-expired';\r\nimport { JwtTokenRequest } from './jwt-token-request';\r\nimport { JWT_CONFIG, JwtConfig } from './token.config';\r\nimport { JwtTokenResponse } from './jwt-token-response';\r\n\r\n@Injectable()\r\nexport class TokenService {\r\n\tconstructor(\r\n\t\t@Inject(JWT_CONFIG) private config: JwtConfig,\r\n\t\tprivate http: HttpClient\r\n\t) {}\r\n\r\n\ttoken(request: JwtTokenRequest): Observable<JwtTokenResponse> {\r\n\t\treturn this.http\r\n\t\t\t.post<JwtTokenResponse>(this.config.tokenEndpoint, request, {\r\n\t\t\t\theaders: { 'Skip-Token': 'true' }\r\n\t\t\t})\r\n\t\t\t.pipe(\r\n\t\t\t\tmap(token => {\r\n\t\t\t\t\tif (token && token.access_token) {\r\n\t\t\t\t\t\t// store token\r\n\t\t\t\t\t\tthis.config.setToken(token);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * This method gets the token from the storage\r\n\t * check if it is still valid if it is it will be returned\r\n\t * otherwise the token endpoint will be called to create a new token\r\n\t * with the refresh_token\r\n\t */\r\n\tget(): Observable<JwtTokenResponse> {\r\n\t\treturn this.config.getToken().pipe(\r\n\t\t\tmergeMap(token => {\r\n\t\t\t\tif (token && isTokenExpired(token)) {\r\n\t\t\t\t\tconst request: JwtTokenRequest = {\r\n\t\t\t\t\t\tgrant_type: 'refresh_token',\r\n\t\t\t\t\t\trefresh_token: token.refresh_token\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// todo: should we call authenticate? so we also set the member?\r\n\t\t\t\t\treturn this.token(request);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn observableOf(token);\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\n\r\nimport {\r\n\tHttpRequest,\r\n\tHttpHandler,\r\n\tHttpEvent,\r\n\tHttpInterceptor,\r\n\tHttpHeaders\r\n} from '@angular/common/http';\r\n\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\nimport { mergeMap, finalize, filter, take, switchMap } from 'rxjs/operators';\r\n\r\nimport { JwtConfig, JWT_CONFIG } from './token.config';\r\nimport { JwtTokenResponse } from './jwt-token-response';\r\nimport { TokenService } from './token.service';\r\n\r\n@Injectable()\r\nexport class JwtInterceptor implements HttpInterceptor {\r\n\tprivate _isRefreshingToken = false;\r\n\tprivate _tokenSubject = new BehaviorSubject<JwtTokenResponse>(null);\r\n\r\n\tconstructor(\r\n\t\t@Inject(JWT_CONFIG) private _config: JwtConfig,\r\n\t\tprivate tokenService: TokenService\r\n\t) {}\r\n\r\n\tintercept(\r\n\t\trequest: HttpRequest<any>,\r\n\t\tnext: HttpHandler\r\n\t): Observable<HttpEvent<any>> {\r\n\t\t// todo: Is there a way to ignore some intereceptors like Angular 1 have it?\r\n\t\t// https://github.com/angular/angular/issues/18155#issuecomment-326136484\r\n\t\t// If this header is present the token will not be refreshed!\r\n\t\t// Use this for unprotected urls like token endpoint itself,\r\n\t\t// otherwise you will run into an infinite loop.\r\n\t\tconst skipIssuingToken: boolean = request.headers.has('Skip-Token');\r\n\r\n\t\t// This headers only have \"internal\" purposes for Angular\r\n\t\t// so we actually don't need to send them to the server!\r\n\t\tconst headers = request.headers.delete('Skip-Token');\r\n\r\n\t\tif (skipIssuingToken) {\r\n\t\t\treturn next.handle(request.clone({ headers }));\r\n\t\t} else if (this._isRefreshingToken === false) {\r\n\t\t\t// Thanks to: https://github.com/IntertechInc/http-interceptor-refresh-token\r\n\t\t\tthis._isRefreshingToken = true;\r\n\r\n\t\t\t// Reset here so that the following requests wait until the token\r\n\t\t\t// comes back from the refreshToken call (e.g. for polling).\r\n\t\t\tthis._tokenSubject.next(null);\r\n\r\n\t\t\treturn this.tokenService.get().pipe(\r\n\t\t\t\tmergeMap(token => {\r\n\t\t\t\t\tthis._tokenSubject.next(token);\r\n\r\n\t\t\t\t\treturn next.handle(this._addToken(request, headers, token));\r\n\t\t\t\t}),\r\n\t\t\t\tfinalize(() => (this._isRefreshingToken = false))\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn this._tokenSubject.pipe(\r\n\t\t\tfilter(token => token != null),\r\n\t\t\ttake(1),\r\n\t\t\tswitchMap(token =>\r\n\t\t\t\tnext.handle(this._addToken(request, headers, token))\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tprivate _addToken(\r\n\t\trequest: HttpRequest<any>,\r\n\t\theaders: HttpHeaders,\r\n\t\ttoken: JwtTokenResponse\r\n\t): HttpRequest<any> {\r\n\t\tif (\r\n\t\t\ttoken &&\r\n\t\t\tthis._isWhitelistedHost(\r\n\t\t\t\trequest.url,\r\n\t\t\t\tthis._config.whitelistedDomains\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\treturn request.clone({\r\n\t\t\t\theaders: headers.set(\r\n\t\t\t\t\tthis._config.headerName,\r\n\t\t\t\t\t`${this._config.authScheme}${token.access_token}`\r\n\t\t\t\t)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn request;\r\n\t}\r\n\r\n\t// todo: @opten/gin-tonic?\r\n\tprivate _isWhitelistedHost(url: string, whitelist: Array<string>): boolean {\r\n\t\tconst host: string = this._getHost(url);\r\n\r\n\t\treturn (\r\n\t\t\twhitelist\r\n\t\t\t\t.map(o => this._getHost(o).toLowerCase())\r\n\t\t\t\t.indexOf(host.toLowerCase()) > -1\r\n\t\t);\r\n\t}\r\n\r\n\t// todo: @opten/gin-tonic?\r\n\tprivate _getHost(href: string) {\r\n\t\tif (window.URL) {\r\n\t\t\treturn new URL(href).host;\r\n\t\t}\r\n\r\n\t\t// IE 11\r\n\t\treturn href.match(\r\n\t\t\t/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)([\\/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/\r\n\t\t)[2];\r\n\t}\r\n}\r\n","import {\r\n\tNgModule,\r\n\tOptional,\r\n\tSkipSelf,\r\n\tModuleWithProviders\r\n} from '@angular/core';\r\n\r\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\r\n\r\nimport { JwtConfig, JWT_CONFIG } from './token.config';\r\nimport { JwtInterceptor } from './token.interceptor';\r\nimport { TokenService } from './token.service';\r\n\r\n@NgModule()\r\nexport class JwtModule {\r\n\tconstructor(\r\n\t\t@Optional()\r\n\t\t@SkipSelf()\r\n\t\tparentModule: JwtModule\r\n\t) {\r\n\t\tif (parentModule) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`JwtModule is already loaded. It should only be imported in your application's main module.`\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic forRoot(config: JwtConfig): ModuleWithProviders {\r\n\t\treturn {\r\n\t\t\tngModule: JwtModule,\r\n\t\t\tproviders: [\r\n\t\t\t\t{\r\n\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\r\n\t\t\t\t\tuseClass: JwtInterceptor,\r\n\t\t\t\t\tmulti: true\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tprovide: JWT_CONFIG,\r\n\t\t\t\t\tuseValue: config\r\n\t\t\t\t},\r\n\t\t\t\tTokenService\r\n\t\t\t]\r\n\t\t};\r\n\t}\r\n}\r\n"]}