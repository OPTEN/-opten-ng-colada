{"version":3,"file":"opten-ng-jwt.js.map","sources":["ng://@opten/ng-jwt/lib/is-token-expired.ts","ng://@opten/ng-jwt/lib/token.config.ts","ng://@opten/ng-jwt/lib/token.service.ts","ng://@opten/ng-jwt/lib/token.interceptor.ts","ng://@opten/ng-jwt/lib/jwt.module.ts"],"sourcesContent":["import { JwtTokenResponse } from './jwt-token-response';\r\n\r\nfunction getTokenExpirationDate(token: JwtTokenResponse): Date {\r\n\tif (!token || token == null || !token.expiration) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst date: Date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n\tdate.setUTCSeconds(token.expiration);\r\n\r\n\treturn date;\r\n}\r\n\r\nexport function isTokenExpired(\r\n\ttoken: JwtTokenResponse,\r\n\toffsetSeconds?: number\r\n): boolean {\r\n\toffsetSeconds = offsetSeconds || 0;\r\n\r\n\tconst date: Date = getTokenExpirationDate(token);\r\n\r\n\tif (!date || date == null) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { JwtTokenResponse } from './jwt-token-response';\r\n\r\nexport type JwtConfig = {\r\n\ttokenEndpoint: string;\r\n\theaderName: string;\r\n\tauthScheme: string;\r\n\twhitelistedDomains: Array<string>;\r\n\tsetToken: (token: JwtTokenResponse) => void;\r\n\tgetToken: () => Observable<JwtTokenResponse>;\r\n};\r\n\r\nexport const JWT_CONFIG = new InjectionToken<JwtConfig>('jwt-config');\r\n","import { Injectable, Inject } from '@angular/core';\r\n\r\nimport { HttpClient } from '@angular/common/http';\r\n\r\nimport { Observable, of as observableOf } from 'rxjs';\r\nimport { mergeMap, map } from 'rxjs/operators';\r\n\r\nimport { isTokenExpired } from './is-token-expired';\r\nimport { JwtTokenRequest } from './jwt-token-request';\r\nimport { JWT_CONFIG, JwtConfig } from './token.config';\r\nimport { JwtTokenResponse } from './jwt-token-response';\r\n\r\n@Injectable()\r\nexport class TokenService {\r\n\tconstructor(\r\n\t\t@Inject(JWT_CONFIG) private config: JwtConfig,\r\n\t\tprivate http: HttpClient\r\n\t) {}\r\n\r\n\ttoken(request: JwtTokenRequest): Observable<JwtTokenResponse> {\r\n\t\treturn this.http\r\n\t\t\t.post<JwtTokenResponse>(this.config.tokenEndpoint, request, {\r\n\t\t\t\theaders: { 'Skip-Token': 'true' }\r\n\t\t\t})\r\n\t\t\t.pipe(\r\n\t\t\t\tmap(token => {\r\n\t\t\t\t\tif (token && token.access_token) {\r\n\t\t\t\t\t\t// store token\r\n\t\t\t\t\t\tthis.config.setToken(token);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * This method gets the token from the storage\r\n\t * check if it is still valid if it is it will be returned\r\n\t * otherwise the token endpoint will be called to create a new token\r\n\t * with the refresh_token\r\n\t */\r\n\tget(): Observable<JwtTokenResponse> {\r\n\t\treturn this.config.getToken().pipe(\r\n\t\t\tmergeMap(token => {\r\n\t\t\t\tif (token && isTokenExpired(token)) {\r\n\t\t\t\t\tconst request: JwtTokenRequest = {\r\n\t\t\t\t\t\tgrant_type: 'refresh_token',\r\n\t\t\t\t\t\trefresh_token: token.refresh_token\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// todo: should we call authenticate? so we also set the member?\r\n\t\t\t\t\treturn this.token(request);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn observableOf(token);\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\n\r\nimport {\r\n\tHttpRequest,\r\n\tHttpHandler,\r\n\tHttpEvent,\r\n\tHttpInterceptor,\r\n\tHttpHeaders\r\n} from '@angular/common/http';\r\n\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\nimport { mergeMap, finalize, filter, take, switchMap } from 'rxjs/operators';\r\n\r\nimport { JwtConfig, JWT_CONFIG } from './token.config';\r\nimport { JwtTokenResponse } from './jwt-token-response';\r\nimport { TokenService } from './token.service';\r\n\r\n@Injectable()\r\nexport class JwtInterceptor implements HttpInterceptor {\r\n\tprivate _isRefreshingToken = false;\r\n\tprivate _tokenSubject = new BehaviorSubject<JwtTokenResponse>(null);\r\n\r\n\tconstructor(\r\n\t\t@Inject(JWT_CONFIG) private _config: JwtConfig,\r\n\t\tprivate tokenService: TokenService\r\n\t) {}\r\n\r\n\tintercept(\r\n\t\trequest: HttpRequest<any>,\r\n\t\tnext: HttpHandler\r\n\t): Observable<HttpEvent<any>> {\r\n\t\t// todo: Is there a way to ignore some intereceptors like Angular 1 have it?\r\n\t\t// https://github.com/angular/angular/issues/18155#issuecomment-326136484\r\n\t\t// If this header is present the token will not be refreshed!\r\n\t\t// Use this for unprotected urls like token endpoint itself,\r\n\t\t// otherwise you will run into an infinite loop.\r\n\t\tconst skipIssuingToken: boolean = request.headers.has('Skip-Token');\r\n\r\n\t\t// This headers only have \"internal\" purposes for Angular\r\n\t\t// so we actually don't need to send them to the server!\r\n\t\tconst headers = request.headers.delete('Skip-Token');\r\n\r\n\t\tif (skipIssuingToken) {\r\n\t\t\treturn next.handle(request.clone({ headers }));\r\n\t\t} else if (this._isRefreshingToken === false) {\r\n\t\t\t// Thanks to: https://github.com/IntertechInc/http-interceptor-refresh-token\r\n\t\t\tthis._isRefreshingToken = true;\r\n\r\n\t\t\t// Reset here so that the following requests wait until the token\r\n\t\t\t// comes back from the refreshToken call (e.g. for polling).\r\n\t\t\tthis._tokenSubject.next(null);\r\n\r\n\t\t\treturn this.tokenService.get().pipe(\r\n\t\t\t\tmergeMap(token => {\r\n\t\t\t\t\tthis._tokenSubject.next(token);\r\n\r\n\t\t\t\t\treturn next.handle(this._addToken(request, headers, token));\r\n\t\t\t\t}),\r\n\t\t\t\tfinalize(() => (this._isRefreshingToken = false))\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn this._tokenSubject.pipe(\r\n\t\t\tfilter(token => token != null),\r\n\t\t\ttake(1),\r\n\t\t\tswitchMap(token =>\r\n\t\t\t\tnext.handle(this._addToken(request, headers, token))\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tprivate _addToken(\r\n\t\trequest: HttpRequest<any>,\r\n\t\theaders: HttpHeaders,\r\n\t\ttoken: JwtTokenResponse\r\n\t): HttpRequest<any> {\r\n\t\tif (\r\n\t\t\ttoken &&\r\n\t\t\tthis._isWhitelistedHost(\r\n\t\t\t\trequest.url,\r\n\t\t\t\tthis._config.whitelistedDomains\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\treturn request.clone({\r\n\t\t\t\theaders: headers.set(\r\n\t\t\t\t\tthis._config.headerName,\r\n\t\t\t\t\t`${this._config.authScheme}${token.access_token}`\r\n\t\t\t\t)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn request;\r\n\t}\r\n\r\n\t// todo: @opten/gin-tonic?\r\n\tprivate _isWhitelistedHost(url: string, whitelist: Array<string>): boolean {\r\n\t\tconst host: string = this._getHost(url);\r\n\r\n\t\treturn (\r\n\t\t\twhitelist\r\n\t\t\t\t.map(o => this._getHost(o).toLowerCase())\r\n\t\t\t\t.indexOf(host.toLowerCase()) > -1\r\n\t\t);\r\n\t}\r\n\r\n\t// todo: @opten/gin-tonic?\r\n\tprivate _getHost(href: string) {\r\n\t\tif (window.URL) {\r\n\t\t\treturn new URL(href).host;\r\n\t\t}\r\n\r\n\t\t// IE 11\r\n\t\treturn href.match(\r\n\t\t\t/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)([\\/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/\r\n\t\t)[2];\r\n\t}\r\n}\r\n","import {\r\n\tNgModule,\r\n\tOptional,\r\n\tSkipSelf,\r\n\tModuleWithProviders\r\n} from '@angular/core';\r\n\r\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\r\n\r\nimport { JwtConfig, JWT_CONFIG } from './token.config';\r\nimport { JwtInterceptor } from './token.interceptor';\r\nimport { TokenService } from './token.service';\r\n\r\n@NgModule()\r\nexport class JwtModule {\r\n\tconstructor(\r\n\t\t@Optional()\r\n\t\t@SkipSelf()\r\n\t\tparentModule: JwtModule\r\n\t) {\r\n\t\tif (parentModule) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`JwtModule is already loaded. It should only be imported in your application's main module.`\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic forRoot(config: JwtConfig): ModuleWithProviders {\r\n\t\treturn {\r\n\t\t\tngModule: JwtModule,\r\n\t\t\tproviders: [\r\n\t\t\t\t{\r\n\t\t\t\t\tprovide: HTTP_INTERCEPTORS,\r\n\t\t\t\t\tuseClass: JwtInterceptor,\r\n\t\t\t\t\tmulti: true\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tprovide: JWT_CONFIG,\r\n\t\t\t\t\tuseValue: config\r\n\t\t\t\t},\r\n\t\t\t\tTokenService\r\n\t\t\t]\r\n\t\t};\r\n\t}\r\n}\r\n"],"names":["observableOf"],"mappings":"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"}
